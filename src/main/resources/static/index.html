<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>仓库食材拿取</title>
    <style>
        body { font-family: Arial, Helvetica, sans-serif; margin: 24px; }
        .controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 12px; }
        .controls .group { display: flex; gap: 8px; align-items: center; }
        .lane { position: relative; height: 80px; border: 1px solid #ddd; margin: 16px 0; border-radius: 6px; padding: 8px; }
        .tick { position: absolute; bottom: 0; width: 1px; background: #ccc; height: 30px; }
        .tick-label { position: absolute; bottom: 34px; transform: translateX(-50%); font-size: 12px; color: #666; }
        .point { position: absolute; top: 10px; transform: translate(-50%, -50%); width: 10px; height: 10px; border-radius: 50%; background: #888; }
        .point.label { top: 28px; font-size: 12px; color: #555; background: transparent; width: auto; height: auto; transform: translate(-50%, 0); }
        .head { position: absolute; top: 8px; transform: translate(-50%, -50%); width: 14px; height: 14px; border-radius: 50%; background: #1976d2; }
        .seg { position: absolute; top: 8px; height: 2px; background: #1976d2; transform-origin: left center; }
        .legend { display: flex; gap: 16px; font-size: 14px; color: #333; }
        .chip { padding: 4px 8px; border-radius: 12px; background: #f1f1f1; }
        .result { white-space: pre-wrap; background: #fafafa; padding: 12px; border: 1px solid #eee; border-radius: 6px; }
        .toolbar { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin: 12px 0; }
        .compare { margin-top: 16px; }
        table { border-collapse: collapse; width: 100%; max-width: 900px; }
        th, td { border: 1px solid #e5e5e5; padding: 8px 10px; font-size: 14px; text-align: left; }
        th { background: #fafafa; }
    </style>
</head>
<body>
    <h2>食材拿取可视化（FCFS / SSTF / SCAN）</h2>
    <div class="controls">
        <div class="group"><label>初始位置 <input id="initial" type="number" value="0" /></label></div>
        <div class="group"><label>随机请求个数 <input id="count" type="number" value="6" min="1" max="50" /></label> <button id="btn-generate">生成随机请求</button></div>
        <div class="group"><label>算法
            <select id="algorithm">
                <option value="FCFS">FCFS</option>
                <option value="SSTF">SSTF</option>
                <option value="SCAN">SCAN</option>
            </select>
        </label>
        <button id="btn-run">运行调度</button></div>
        <div class="group">
            <label>播放速度
                <select id="speed">
                    <option value="0.5">0.5x</option>
                    <option value="1" selected>1x</option>
                    <option value="2">2x</option>
                    <option value="4">4x</option>
                </select>
            </label>
            <button id="btn-play">播放</button>
            <button id="btn-pause">暂停</button>
            <button id="btn-step">单步</button>
            <button id="btn-reset">重置</button>
        </div>
        <div class="group"><button id="btn-compare">一键对比三种算法</button></div>
    </div>

    <div class="legend">
        <span class="chip">蓝点：机械臂位置</span>
        <span class="chip">灰点：请求位置</span>
    </div>

    <h3>仓库分布</h3>
    <div id="warehouse" class="lane"></div>

    <h3>请求位置</h3>
    <div id="requests" class="lane"></div>

    <h3>调度路径（<span id="alg-label">FCFS</span>）</h3>
    <div id="path" class="lane"></div>

    <div class="toolbar">
        <div>初始位置：<b id="info-start">-</b></div>
        <div>结束位置：<b id="info-end">-</b></div>
        <div>总距离：<b id="info-distance">-</b></div>
        <div>耗时(估算)：<b id="info-time">-</b></div>
    </div>

    <h3>调度结果</h3>
    <div id="result" class="result"></div>

    <div class="compare">
        <h3>算法对比（同一批请求）</h3>
        <table>
            <thead>
                <tr><th>算法</th><th>处理顺序</th><th>总距离</th><th>结束位置</th><th>估算耗时</th><th>播放</th></tr>
            </thead>
            <tbody id="compare-body"></tbody>
        </table>
    </div>

    <script>
        const api = {
            warehouse: '/api/warehouse/ingredients',
            random: (count) => `/api/warehouse/random-requests?count=${count}`,
            schedule: '/api/schedule'
        };

        let warehouseData = {}; // pos -> name
        let requestPositions = [];
        let lastSchedule = null; // 保存最近一次调度结果
        let animation = { timer: null, playing: false, progressIndex: 0, points: [], min: 0, max: 0, initial: 0 };

        const el = (id) => document.getElementById(id);

        function laneBounds(dataPositions) {
            if (!dataPositions.length) return {min:0, max:1};
            const min = Math.min(...dataPositions);
            const max = Math.max(...dataPositions);
            if (min === max) return {min: min - 1, max: max + 1};
            return {min, max};
        }

        function xFromPos(pos, min, max, width) {
            const ratio = (pos - min) / (max - min);
            return 8 + ratio * (width - 16);
        }

        function clearLane(node) { node.innerHTML = ''; }

        function drawTicks(node, min, max) {
            const width = node.clientWidth;
            const step = Math.max(1, Math.round((max - min) / 10));
            for (let p = min; p <= max; p += step) {
                const x = xFromPos(p, min, max, width);
                const tick = document.createElement('div');
                tick.className = 'tick';
                tick.style.left = `${x}px`;
                const label = document.createElement('div');
                label.className = 'tick-label';
                label.style.left = `${x}px`;
                label.textContent = p;
                node.appendChild(tick);
                node.appendChild(label);
            }
        }

        function drawPoints(node, positions, min, max, color='#888') {
            const width = node.clientWidth;
            positions.forEach(p => {
                const x = xFromPos(p, min, max, width);
                const dot = document.createElement('div');
                dot.className = 'point';
                dot.style.left = `${x}px`;
                dot.style.background = color;
                const label = document.createElement('div');
                label.className = 'point label';
                label.style.left = `${x}px`;
                label.textContent = p;
                node.appendChild(dot);
                node.appendChild(label);
            });
        }

        function drawPathStatic(node, processedOrder, initial, min, max) {
            const width = node.clientWidth;
            let current = initial;
            // 绘制初始位置
            const x0 = xFromPos(current, min, max, width);
            const head = document.createElement('div');
            head.className = 'head';
            head.style.left = `${x0}px`;
            node.appendChild(head);
            // 绘制每段移动
            processedOrder.forEach(target => {
                const x1 = xFromPos(target, min, max, width);
                const seg = document.createElement('div');
                seg.className = 'seg';
                const left = Math.min(x0, x1);
                const len = Math.abs(x1 - x0);
                seg.style.left = `${left}px`;
                seg.style.width = `${len}px`;
                node.appendChild(seg);
                // 目标点
                const dot = document.createElement('div');
                dot.className = 'head';
                dot.style.left = `${x1}px`;
                node.appendChild(dot);
                current = target;
            });
        }

        function resetAnimation() {
            if (animation.timer) { clearInterval(animation.timer); animation.timer = null; }
            animation.playing = false;
            animation.progressIndex = 0;
        }

        function setupAnimation(processedOrder, initial, min, max) {
            resetAnimation();
            animation.points = [initial, ...processedOrder];
            animation.min = min; animation.max = max; animation.initial = initial;
            // 首帧渲染静态
            const lane = el('path');
            clearLane(lane);
            drawTicks(lane, min, max);
            drawPoints(lane, processedOrder, min, max, '#888');
            const x0 = xFromPos(initial, min, max, lane.clientWidth);
            const head = document.createElement('div');
            head.className = 'head';
            head.style.left = `${x0}px`;
            head.id = 'anim-head';
            lane.appendChild(head);
        }

        function playAnimation(stepDistances) {
            if (!animation.points.length) return;
            const lane = el('path');
            const head = document.getElementById('anim-head');
            const speed = Number(el('speed').value); // 倍速
            const basePixelsPerSec = 120; // 基准速度：每秒 120 像素
            const width = lane.clientWidth;

            if (!animation.playing) {
                animation.playing = true;
                let i = 0; // 段索引（points[i] -> points[i+1]）
                let startTime = null;

                const animate = (timestamp) => {
                    if (!animation.playing) return; // 暂停
                    if (startTime === null) startTime = timestamp;
                    // 如果已经到最后
                    if (i >= animation.points.length - 1) { animation.playing = false; return; }
                    const from = animation.points[i];
                    const to = animation.points[i + 1];
                    const xFrom = xFromPos(from, animation.min, animation.max, width);
                    const xTo = xFromPos(to, animation.min, animation.max, width);
                    const distancePx = Math.abs(xTo - xFrom);
                    const duration = distancePx / (basePixelsPerSec * speed) * 1000; // ms
                    const elapsed = timestamp - startTime;
                    const t = Math.min(1, elapsed / duration);
                    const x = xFrom + (xTo - xFrom) * t;
                    head.style.left = `${x}px`;
                    if (t >= 1) {
                        // 画出已完成的线段
                        const seg = document.createElement('div');
                        seg.className = 'seg';
                        seg.style.left = `${Math.min(xFrom, xTo)}px`;
                        seg.style.width = `${Math.abs(xTo - xFrom)}px`;
                        lane.appendChild(seg);
                        // 下一段
                        i += 1; startTime = null;
                        requestAnimationFrame(animate);
                    } else {
                        requestAnimationFrame(animate);
                    }
                };
                requestAnimationFrame(animate);
            }
        }

        function stepAnimation() {
            if (!animation.points.length) return;
            const lane = el('path');
            const head = document.getElementById('anim-head');
            const width = lane.clientWidth;
            if (animation.progressIndex >= animation.points.length - 1) return;
            const from = animation.points[animation.progressIndex];
            const to = animation.points[animation.progressIndex + 1];
            const xFrom = xFromPos(from, animation.min, animation.max, width);
            const xTo = xFromPos(to, animation.min, animation.max, width);
            head.style.left = `${xTo}px`;
            const seg = document.createElement('div'); seg.className = 'seg';
            seg.style.left = `${Math.min(xFrom, xTo)}px`; seg.style.width = `${Math.abs(xTo - xFrom)}px`;
            lane.appendChild(seg);
            animation.progressIndex += 1;
        }

        async function loadWarehouse() {
            const res = await fetch(api.warehouse);
            warehouseData = await res.json();
            const positions = Object.keys(warehouseData).map(Number);
            const lane = el('warehouse');
            clearLane(lane);
            const {min, max} = laneBounds(positions);
            drawTicks(lane, min, max);
            drawPoints(lane, positions, min, max, '#888');
        }

        async function generateRequests() {
            const count = Number(el('count').value || 6);
            const res = await fetch(api.random(count));
            requestPositions = await res.json();
            const lane = el('requests');
            clearLane(lane);
            const {min, max} = laneBounds(requestPositions);
            drawTicks(lane, min, max);
            drawPoints(lane, requestPositions, min, max, '#888');
        }

        async function runSchedule() {
            const algorithm = el('algorithm').value;
            el('alg-label').textContent = algorithm;
            const initial = Number(el('initial').value || 0);
            const res = await fetch(api.schedule + `?algorithm=${algorithm}&initialPosition=${initial}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestPositions)
            });
            const data = await res.json();
            const lane = el('path');
            clearLane(lane);
            const positions = [...requestPositions, initial];
            const {min, max} = laneBounds(positions);
            drawTicks(lane, min, max);
            drawPoints(lane, requestPositions, min, max, '#888');
            drawPathStatic(lane, data.processedOrder || [], initial, min, max);
            // 保存并展示关键信息
            lastSchedule = { data, initial, min, max };
            const endPos = (data.processedOrder && data.processedOrder.length)
                ? data.processedOrder[data.processedOrder.length - 1]
                : initial;
            el('info-start').textContent = String(initial);
            el('info-end').textContent = String(endPos);
            el('info-distance').textContent = String(data.totalDistance);
            // 估算时间（以基准速度换算像素 -> 时间，粗略近似）：
            const basePixelsPerSec = 120, widthPx = lane.clientWidth;
            const spanPx = Math.max(1, widthPx - 16);
            const domain = Math.max(1, max - min);
            const pixelsPerUnit = spanPx / domain;
            const px = (data.totalDistance || 0) * pixelsPerUnit;
            const seconds = px / basePixelsPerSec;
            el('info-time').textContent = `${seconds.toFixed(2)} s (1x)`;
            el('result').textContent = [
                `算法: ${data.algorithmName}`,
                `处理顺序: ${JSON.stringify(data.processedOrder)}`,
                `每步距离: ${JSON.stringify(data.stepDistances)}`,
                `总距离: ${data.totalDistance}`,
                ...(data.stepDetails || [])
            ].join('\n');
        }

        async function runCompare() {
            const initial = Number(el('initial').value || 0);
            const body = el('compare-body');
            body.innerHTML = '';
            const algos = ['FCFS','SSTF','SCAN'];
            const reqs = requestPositions;
            const calls = algos.map(a => fetch(api.schedule + `?algorithm=${a}&initialPosition=${initial}`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(reqs)
            }).then(r => r.json().then(data => ({ algo: a, data }))));
            const results = await Promise.all(calls);
            const positions = [...requestPositions, initial];
            const {min, max} = laneBounds(positions);
            const lane = el('path'); const spanPx = Math.max(1, lane.clientWidth - 16);
            const domain = Math.max(1, max - min); const pixelsPerUnit = spanPx / domain; const basePixelsPerSec = 120;
            results.forEach(({algo, data}) => {
                const endPos = (data.processedOrder && data.processedOrder.length)
                    ? data.processedOrder[data.processedOrder.length - 1] : initial;
                const px = (data.totalDistance || 0) * pixelsPerUnit;
                const sec = px / basePixelsPerSec;
                const tr = document.createElement('tr');
                const tdAlg = document.createElement('td'); tdAlg.textContent = algo;
                const tdOrder = document.createElement('td'); tdOrder.textContent = JSON.stringify(data.processedOrder);
                const tdDist = document.createElement('td'); tdDist.textContent = String(data.totalDistance);
                const tdEnd = document.createElement('td'); tdEnd.textContent = String(endPos);
                const tdTime = document.createElement('td'); tdTime.textContent = `${sec.toFixed(2)} s (1x)`;
                const tdPlay = document.createElement('td');
                const btn = document.createElement('button'); btn.textContent = '播放';
                btn.onclick = () => { el('algorithm').value = algo; el('alg-label').textContent = algo; lastSchedule = { data, initial, min, max }; setupAnimation(data.processedOrder||[], initial, min, max); };
                tdPlay.appendChild(btn);
                tr.appendChild(tdAlg); tr.appendChild(tdOrder); tr.appendChild(tdDist); tr.appendChild(tdEnd); tr.appendChild(tdTime); tr.appendChild(tdPlay);
                body.appendChild(tr);
            });
        }

        // 初始化
        window.addEventListener('load', async () => {
            await loadWarehouse();
            await generateRequests();
        });
        el('btn-generate').addEventListener('click', generateRequests);
        el('btn-run').addEventListener('click', runSchedule);
        el('btn-compare').addEventListener('click', runCompare);
        el('btn-play').addEventListener('click', () => {
            if (!lastSchedule) return;
            el('alg-label').textContent = lastSchedule.data.algorithmName || el('algorithm').value;
            setupAnimation(lastSchedule.data.processedOrder||[], lastSchedule.initial, lastSchedule.min, lastSchedule.max);
            playAnimation(lastSchedule.data.stepDistances||[]);
        });
        el('btn-pause').addEventListener('click', () => { animation.playing = false; });
        el('btn-step').addEventListener('click', () => { stepAnimation(); });
        el('btn-reset').addEventListener('click', () => {
            if (!lastSchedule) return; setupAnimation(lastSchedule.data.processedOrder||[], lastSchedule.initial, lastSchedule.min, lastSchedule.max);
        });
    </script>
</body>
</html>


